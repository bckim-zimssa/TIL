# interface

ts의 핵심 원리중 하나는 type checking이 값이 가지는 모양에 집중한다는 것이다.
이는 "duck typeing" or "structural subtyping" 이라고 불린다.  

ts에서, `interfaces`는 이러한 type들을 이름 붙이는 역할을 한다. 
프로젝트 내부, 외부에서 지켜야하는 규칙을 정의하는 방식이다. 

인터페이스를 통해 객체를 만들 수 없다.

## duck typing

___
**note**
Duck typing이란? 객체의 타입을 객체의 변수와 메서드의 집합으로 결정하는 것을 의미. 
___


```ts
function printLabel(labeledObj: { label: string }) {
  console.log(labeledObj.label);
}

let myObj = { size: 10, label: "Size 10 Object" };
printLabel(myObj);
```

type checker는 `printLabel` 호출을 체크한다. 이 함수는 하나의 parameter를 가지고, 이 파라미터는 string 타입의 label property가 요구된다. 

여기서 myObject는 실제로 더 많은 프로퍼티를 가지고 있는데(size 프로퍼티가 또 있다),  
컴파일러는 요구되는 프로퍼티가 있는지, 그리고 type이 맞는지만을 체크한다. 


우리는 같은 예시를 `interface`를 사용해서 다시 작성할 수 있다. 
`interface`를 사용해서 label property는 `string` 타입이라는 요구사항을 명시할 수 있다. 

```ts
interface LabeledValue {
  label: string;
}

function printLabel(labeledObj: LabeledValue) {
  console.log(labeledObj.label);
}

let myObj = { size: 10, label: "Size 10 Object" };
printLabel(myObj);
```

`interface` LabeledValue는 하나의 이름으로 이전의 예시에서의 요구사항을 서술하는데 사용할 수 있다.  
`printLable`에 전달하는 객체가 이 인터페이스를 구현한다고 명시적으로 말하지 않아도 된다는 점을 주목해야한다. 
shape 그 자체가 중요한것이다. 만약에 함수에 넘겨주는 파라미터 object가 열거된 요구사항을 충족한다면, 그것으로 okay.

type checker는 이러한 properties가 어떠한 순서로 들어와도 상관없다. 그냥 properties가 있고, 요구되는 type이면 된다. 


```typescript
interface LabeledValue {
    label: string;
}

function printLabel(labeledObj: LabeledValue) {
    console.log(labeledObj.label);
}
// label이 2번째로 왔고(순서랑 상관 없고)
// type만 맞으면 된다.
let myObj = {size: 10, label: "Size 10 Object"};
printLabel(myObj);
```

위의 예시의 경우에는 `myObj` 객체가 `interface`를 구현한다고 명시하지 않았는데 인자로 넘어간다. typescript에서는 다른 언어와 달리 그럴 필요가 없다. `shape`만 맞으면 구현했다고 보는 것이다. 즉, `myObj`에 label이 있기 때문에 가능한 것.

개인적인 생각으로는 interface를 구현한 객체라고 보는 것 같고, 다형성 차원에서 인자가 넘어가는 것 같다.


## optional properties


모든 프로퍼티가 필요로 하는 것은 아니다. 
몇몇 프로퍼티는 특정 조건에서 있을 수도 있고, 없을 수도 있다.  

These optional properties are popular when creating patterns like “option bags” where you pass an object to a function that only has a couple of properties filled in.

Here’s an example of this pattern:

인터페이스의 이점은 사용 가능성이 있는 프로퍼티를 명시해주고, 인터페이스의 프로퍼티가 아닌 부분이 사용되는 것을 막아줄 수 있다는 것이다. 

```ts
interface SquareConfig {
    color?: string;
    width?: number;
}

function createSquare(config: SquareConfig): {color: string; area: number} {
    let newSquare = {color: "white", area: 100};
    if (config.color) {
        newSquare.color = config.color;
    }
    if (config.width) {
        newSquare.area = config.width * config.width;
    }
    return newSquare;
}

let mySquare = createSquare({color: "black"});
```

optional properties를 가지는 interface는 다른 interface와 비슷하게 쓰여진다.  
각각의 optional property는 `?`를 property 이름뒤에 명시해주면 된다. 

그렇다면 왜 optional properties를 사용할까?

이용가능성이 있는 프로퍼티를 서술할 수 있으면서, interface의 부분이 아닌 프로퍼티 사용을 막을 수 있다. 

예를들어, 만약 createSqure 함수에서 color 프로퍼티의 

For example, had we mistyped the name of the color property in createSquare, we would get an error message letting us know:

```ts
interface SquareConfig {
  color?: string;
  width?: number;
}

function createSquare(config: SquareConfig): { color: string; area: number } {
  let newSquare = { color: "white", area: 100 };
  if (config.clor) {
      
/*
Property 'clor' does not exist on type 'SquareConfig'. Did you mean 'color'?
    // Error: Property 'clor' does not exist on type 'SquareConfig'
    newSquare.color = config.clor;
Property 'clor' does not exist on type 'SquareConfig'. Did you mean 'color'?
  }
*/ 
  if (config.width) {
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}

let mySquare = createSquare({ color: "black" });
```

## readonly

객체를 생성할 때, 생성자(여기서는 object literal)로 프로퍼티에 값을 할당하고 그 이후에는 값의 수정을 막아주는 역할을 함.
```typescript
interface Point {
    readonly x: number;
    readonly y: number;
}
let p1: Point = { x: 10, y: 20 };
p1.x = 5; // error!
```

## readonly vs const

프로퍼티의 경우에는 `readonly`
일반 변수의 경우에 `const`