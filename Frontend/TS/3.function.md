# function

TS에서 클래스, 네임스페이스, 모듈이 있지만, 함수는 어떤 일을 하는지 서술하는데 있어서 중요한 역할을 한다.  
TS는 JS 함수에 몇몇의 능력(?)을 추가해준다. 

## functions 

TS에서 함수는 JS와 마찬가지로 named function 또는 anonymous function으로 만들 수 있다. 

To begin, just as in JavaScript, TypeScript functions can be created both as a named function or as an anonymous function. This allows you to choose the most appropriate approach for your application, whether you’re building a list of functions in an API or a one-off function to hand off to another function.

To quickly recap what these two approaches look like in JavaScript:


```ts
// named function
function add(x, y){
  return x+y;
}
// anonymous function
const func = function(x,y){
  return x+y;
}
```

JS에서와 마찬가지로, 함수는 body 외부의 변수를 참조할 수 있다.  
외부의 변수를 참조할 때, 그 변수를 `capture`한다고 부른다.  


Just as in JavaScript, functions can refer to variables outside of the function body. When they do so, they’re said to capture these variables. While understanding how this works (and the trade-offs when using this technique) is outside of the scope of this article, having a firm understanding how this mechanic works is an important piece of working with JavaScript and TypeScript.

```ts
let z = 100;

function addToZ(x, y) {
  return x + y + z;
}
```


## Typing the function 

```ts
function add(x: number, y: number): number {
  return x + y;
}

let myAdd = function (x: number, y: number): number {
  return x + y;
};
```

각각의 파라미터에 type을 추가해줄 수 있다. 
함수 자체에 type을 적어주면 이는 return type에 대한 것이다.  
ts는 return statements를 통해서 return의 type을 알 수 있다. 
so we can also optionally leave this off in many cases.

## Writing the function type

Now that we’ve typed the function, let’s write the full type of the function out by looking at each piece of the function type.

```ts
let myAdd: (x: number, y: number) => number = function (
  x: number,
  y: number
): number {
  return x + y;
};
```

A function’s type has the same two parts: the type of the arguments and the return type. When writing out the whole function type, both parts are required. We write out the parameter types just like a parameter list, giving each parameter a name and a type. This name is just to help with readability. We could have instead written:

```ts
let myAdd: (baseValue: number, increment: number) => number = function (
  x: number,
  y: number
): number {
  return x + y;
};
```

As long as the parameter types line up, it’s considered a valid type for the function, regardless of the names you give the parameters in the function type.

The second part is the return type. We make it clear which is the return type by using an arrow (=>) between the parameters and the return type. As mentioned before, this is a required part of the function type, so if the function doesn’t return a value, you would use void instead of leaving it off.

Of note, only the parameters and the return type make up the function type. Captured variables are not reflected in the type. In effect, captured variables are part of the “hidden state” of any function and do not make up its API.



```ts
function add(x: number, y: number): number { 
  return x + y;
}
const func = function(x: number, y: number): number {
  return x + y;
}
// return이 없을때
function add(a: number, b: number): void {
  console.log(a,b);
}
// 함수를 리턴할때
// 화살표 함수를 리턴하는데, 그 함수의 파라미터의 타입과 리턴 타입 반환
function add(a: number, b: number): (c: string) => number {
  return (c: string) => {
    return 3;
  }
}

const obj2 : { a: (b:number) => string} = {
  a(b: number){
    return 'hello'
  }
}
// 매개변수가 안쓰일 수도 있을 때, 즉, 오버로딩하고 싶을 때
const obj2 : { a: (b?:number) => string} = {
  a(b?: number){
    return 'hello'
  }
}
obj2.a(3);
obj2.a(); // 있는 경우, 없는 경우 모두 사용 가능.
```
